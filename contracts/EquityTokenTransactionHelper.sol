pragma solidity ^0.4.24;

import "./ConvertLib.sol";
import "./SafeMath.sol";
import "./EquityTokenFactory.sol";
import "./EquityToken.sol";
import "./EquityTokenTransaction.sol";

contract EquityTokenTransactionHelper is EquityTokenTransaction {

//-----TokenTransactions------------------------------------------------------------------------------------------------------------------
  /* This section determines transaction protocolls of the issued equity token
        - this section contains the public but forwarding send functions!
        -
        */

    ///@dev fires an event after percentage of dividend is determined and transfered    
    event Dividend(uint _txpercentage);

    ///@notice native ERC777 send function
    function send(address _to, uint _txamount) public returns(bool success_) {
        _doSend(msg.sender, _to, _txamount, "", msg.sender, "");
        return true;
    }

    function send(address _to, uint _txamount, bytes _userData) public returns(bool success_) {
        _doSend(msg.sender, _to, _txamount, _userData, msg.sender, "");
        return true;
    }
  
    ///@notice Send _amount of tokens on behalf of the address _from to the address _to.
    ///@param _userData Data generated by the user to be sent to the recipient
    ///@param _operatorData Data generated by the operator to be sent to the recipient
    ///@notice ERC777 mandatory
    function operatorSend(address _from, address _to, uint _txamount, bytes _userData, bytes _operatorData) public returns(bool success_) {
        require((isOperatorFor(msg.sender, _from)), "sender is not authorized to operate with _from's account");
        _doSend(_from, _to, _txamount, _userData, msg.sender, _operatorData);
        return true;
    }

    ///@return returning a trancheId allows to further distinct equity-tranches into sub-tranches by token holder
    /// this enables token governance on company AND on token holder level (sub-tranches)
    ///@notice native EIP1410 send function
    function sendByTranche(uint _trancheId, address _to, uint _txamount) external returns(uint) {
        uint receiverTrancheId_ = _doSend(_trancheId, msg.sender, _to, _txamount, "", msg.sender, "");
        return receiverTrancheId_;
    }
    function sendByTranche(uint _trancheId, address _to, uint _txamount, bytes _userData) external returns(uint) {
        uint receiverTrancheId_ = _doSend(_trancheId, msg.sender, _to, _txamount, _userData, msg.sender, "");
        return receiverTrancheId_;
    }

    ///@notice Send _amount of tokens on behalf of the address _from to the address _to
    ///@notice EIP1410 mandatory for backward interoperability with ERC777
    function operatorSendByTranche(uint _trancheId, address _from, address _to, uint _txamount, bytes _userData, bytes _operatorData) external returns(uint) {
        require((isOperatorFor(msg.sender, _from)), "sender is not authorized to operate with _from's account");
        uint receiverTrancheId_ = _doSend(_trancheId, _from, _to, _txamount, _userData, msg.sender, _operatorData);
        return receiverTrancheId_;
    }

    ///@dev transfers of security might fail to multiple reasons (e.g. identity of sender and receiver, trading limits, meta state of token)
    ///@dev relies on EIP1066 for Ethereum Standard Codes (ESC) and ERC770 for tranching
    ///@dev only possible to read error code of 'doSend -> require' statement with assembly { call } for more elaborated error messages (see Ethereum documentation)
    ///@return ESC (byte), optional specific reason for failure (bytes32), (NOT IMPLEMENTED) destinantion tranche of the token beeing transfered (uint)
    ///@notice EIP1400 proposal
    function canSend(uint _trancheId, address _from, address _to, uint _txamount, bytes _userData) external returns(byte, bytes32, uint) {
        uint receiverTrancheId_ = _doSend(_trancheId, _from, _to, _txamount, _userData, msg.sender, "");
        if(receiverTrancheId_ > 0) {
        return (hex"01", "success", receiverTrancheId_);}
        else {
        return (hex"00", "failure", receiverTrancheId_);}
    }

    ///@dev transfers token from A to B and fires event, additionally updates the TotalDistribution array (shareholder book)
    ///@notice ERC20 mandatory
    ///@dev with _preventLocking parameter, should return _doSend(msg.sender, _to, _txamount, "", msg.sender, "", false) false here!
    function transfer(address _to, uint _txamount) public isERC20 returns(bool success_) {
        _doSend(msg.sender, _to, _txamount, "", msg.sender, "");
        return true;
    }

    ///@dev transfers token from A to B and fires event, additionally updates the TotalDistribution array (shareholder book); transferFrom should be used for withdrawing workflow
    ///@notice ERC20 mandatory
    function transferFrom(address _from, address _to, uint _txamount) public isERC20 returns(bool success_) {
        require((_txamount <= allowed[_from][msg.sender]), "no approval for transaction");

        //@security cannot be after doSend because of tokensReceived re-entry
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_txamount);
        _doSend(_from, _to, _txamount, "", msg.sender, "");
        return true;
    }

    ///@dev pays a dividend to all owner of the shares depending on determined percentage of owners portfolio value
    // dividend is uint (no decimals allowed) -> owners balance has to be divided by 100, to calculate in %
    ///@notice starts with index 1 in array, as 0 is contract deployer = companyowner in most cases
    ///@notice would be also possible with PAYABLE to pay in ether and withdraw() to send ether, but with stocks more elegant
    ///@notice uses default tranches to pay for dividend
    function payDividend(uint _txpercentage) external onlyOwnerOfCom {
        uint _totaldividend;
        for (uint i = 1; i < TotalDistribution.length; i++) {
            uint _temp = _txpercentage.mul(OwnerToBalance[TotalDistribution[i]]/100);
            _totaldividend = _totaldividend.add(_temp);
        }
        require((OwnerToBalance[msg.sender] >= _totaldividend), "insufficient funding to pay dividend");
        for (uint j = 1; j < TotalDistribution.length; j++) {
            uint _txamount = _txpercentage.mul(OwnerToBalance[TotalDistribution[j]]/100);
            _doSend(msg.sender, TotalDistribution[j], _txamount, "", msg.sender, "");
        }
        emit Dividend(_txpercentage);
    }
    
//-----TokenTransactions------------------------------------------------------------------------------------------------------------------    
} 